import {
  CreateCompilerOptionsTypescript,
  createCompiler,
  prepareProxy,
  prepareUrls,
} from 'react-dev-utils/WebpackDevServerUtils'
import clearConsole from 'react-dev-utils/clearConsole'
import openBrowser from 'react-dev-utils/openBrowser'
import chalk from 'chalk'
import webpack from 'webpack'
import WebpackDevServer from 'webpack-dev-server'
import env from './config/env'
import paths from './config/paths'
import createWebpackConfig from './config/webpack.config'
import createWebpackServerConfig from './config/webpack.config.server'
import checkRequiredFiles from './util/check-required-files'


export function start(): void {
  // Do this as the first thing so that any code reading it knows the right env.
  process.env.BABEL_ENV = 'development'
    ; (process.env as any).NODE_ENV = 'development'

  // Warn and crash if required files are missing
  if (!checkRequiredFiles(paths.entries)) return

  if (env.development.server.host) {
    console.log(
      chalk.cyan(
        'Attempting to bind to HOST environment variable: ' +
        chalk.yellow(chalk.bold(env.development.server.host)))
    )
    console.log(
      'If this was unintentional, check that you haven\'t mistakenly set it in your shell.'
    )
    console.log(
      `Learn more here: ${ chalk.yellow('https://bit.ly/CRA-advanced-config') }`
    )
    console.log()
  }


  function run(): void {
    const urls = prepareUrls(
      env.development.server.isHTTPS ? 'https' : 'http',
      env.development.server.host,
      env.development.server.port,
      env.publicUrlOrPath.replace(/\/$/, ''),
    )
    const devSocket = {
      warnings: (warnings: any[]): void =>
        server.sockWrite(server.sockets, 'warnings', warnings),
      errors: (errors: any[]): void =>
        server.sockWrite(server.sockets, 'errors', errors),
    }

    // Create a webpack compiler that is configured with custom messages.
    const config: webpack.Configuration = createWebpackConfig('development')
    const compiler: webpack.Compiler = createCompiler({
      appName: env.appPackageJson.name,
      config,
      urls,
      useYarn: true,
      webpack,
      devSocket,
      useTypeScript: true,
      tscCompileOnError: env.tscCompileOnError,
    } as CreateCompilerOptionsTypescript)

    // Load proxy config
    const proxySetting = env.appPackageJson['proxy']
    const proxyConfig = prepareProxy(
      proxySetting,
      paths.source.public,
      env.publicUrlOrPath.replace(/\/$/, ''),
    )

    // Serve webpack assets generated by the compiler over a web server.
    const serverConfig = createWebpackServerConfig(
      proxyConfig,
      urls.lanUrlForConfig
    )
    const server = new WebpackDevServer(compiler, serverConfig)
    server.listen(env.development.server.port, env.development.server.host, error => {
      if (error) {
        console.log(error)
        return
      }

      if (env.isInteractive) {
        clearConsole()
      }

      // We used to support resolving modules according to `NODE_PATH`.
      // This now has been deprecated in favor of jsconfig/tsconfig.json
      // This lets you use absolute paths in imports inside large monorepos:
      if (process.env.NODE_PATH) {
        console.log(
          chalk.yellow(
            'Setting NODE_PATH to resolve modules absolutely has been deprecated in favor of setting baseUrl in jsconfig.json (or tsconfig.json if you are using TypeScript) and will be removed in a future major release of create-react-app.'
          )
        )
        console.log()
      }

      console.log(chalk.cyan('Starting the development server...\n'))

      // Try to launch browser
      if (env.development.shouldLaunchBrowser) {
        try {
          openBrowser(urls.localUrlForBrowser)
        } catch (error) {
          console.log(chalk.magenta(`Failed to open browser: ${ error }`))
        }
      }


      ['SIGINT', 'SIGTERM'].forEach(function (signal) {
        process.on(signal, function () {
          server.close()
          process.exit()
        })
      })

      if (env.isInteractive || process.env.CI !== 'true') {
        // Gracefully exit when stdin ends
        process.stdin.on('end', function () {
          server.close()
          process.exit()
        })
        process.stdin.resume()
      }
    })
  }

  try {
    run()
  } catch (error) {
    if (error && error.message) {
      console.log(error.message)
    }
    process.exit(1)
  }
}


start()
